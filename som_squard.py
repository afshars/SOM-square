# -*- coding: utf-8 -*-
"""SOM squard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f0Lsy1JTLcwaCN2yjQGsG1SpjyVu4kY_
"""

# import libraries
import numpy as np
import tensorflow as tf
from tensorflow import keras
from keras import backend as K
import random
import matplotlib.pyplot as plt

# Load the Fashion MNIST dataset
fashionMNIST = keras.datasets.fashion_mnist
(x_train, y_train), (x_test, y_test) = fashionMNIST.load_data()
K.clear_session()
print('Load dataset')

# Use a larger subset of the data for training
training = list(range(0, 5000))  # Use first 5000 samples for training
data_first, label = x_train[training], y_train[training]

# Reshape and normalize the data
data = np.reshape(data_first, (data_first.shape[0], 784)) / 255

# Initialize the weights randomly from the data
w_random_num = random.sample(range(len(data)), 400)  # Use 400 samples for weights initialization
w = data[w_random_num]
w = np.reshape(w, (20, 20, 784))  # Use a 20x20 grid

# Parameters
R = 2  # Increase the neighborhood radius
a = 1.1  # Reduce the decay rate for learning rate
epochs = 20  # Use more epochs for training
alpha = 0.5  # Adjust initial learning rate

# SOM Training
D = np.zeros((20, 20))
for E in range(epochs):
    for x in data:
        for i in range(20):
            for j in range(20):
                D[i, j] = np.sum((w[i, j, :] - x) ** 2)

        D_min = np.argmin(D)
        I, J = divmod(D_min, 20)

        for i in range(max(0, I - R), min(20, I + R + 1)):
            for j in range(max(0, J - R), min(20, J + R + 1)):
                w[i, j, :] += alpha * (x - w[i, j, :])
    alpha *= (1 / a)

# Reshape the weights for visualization
w = w.reshape(400, 28, 28)
img = np.zeros((28 * 20, 28 * 20), dtype='f')
for i in range(400):
    r, c = divmod(i, 20)
    img[r * 28:(r + 1) * 28, c * 28:(c + 1) * 28] = w[i]

# Display the SOM result
plt.figure(figsize=(10, 10))
plt.imshow(img, cmap='gray')
plt.title('SOM', color='w')
plt.show()